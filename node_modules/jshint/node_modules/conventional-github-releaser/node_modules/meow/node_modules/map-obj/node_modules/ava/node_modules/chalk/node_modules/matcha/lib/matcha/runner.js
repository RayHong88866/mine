/*!
 * Matcha - Benchmark Constructor
 * Copyright(c) 2011-2012 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * External Dependancies
 */

var EventEmitter = require('events').EventEmitter
  , util = require('util')
  , Timer = require('./timer');

/*!
 * Internal Dependancies
 */

var series = require('./utils').series;

/*!
 * proxy (from, to, event)
 *
 * Proxy an event from one object to another.
 *
 * @param {EventEmitter} from
 * @param {EventEmitter} to
 * @param {String} event
 * @api private
 */

function proxy (from, to, ev) {
  from.on(ev, function () {
    var args = Array.prototype.slice.call(arguments)
      , event = [ ev ].concat(args);
    to.emit.apply(to, event);
  });
};

/*!
 * Primary Exports
 */

module.exports = Runner;

function Runner (suite) {
  this.suite = suite;
}

/*!
 * Inherits from `EventEmitter`
 */

util.inherits(Runner, EventEmitter);

/**
 * .run (callback)
 *
 * Start the entire run sequence for a given
 * suite. The callback will be called upon
 * completion. Will call in the following order:
 *
 * - before hooks
 * - benches
 * - suites
 * - after hooks
 *
 * @param {Function} callback
 * @name run
 * @api public
 */

Runner.prototype.run = function (cb) {
  var self = this;

  var stats = this.stats = { suites: 0, benches: 0 };


  function iterator (fn, next) {
    fn(next);
  }

  this.on('bench start', function() {
    stats.benches++;
  });

  function done () {
    stats.elapsed = self.timer.stop().elapsed;
    self.emit('end', stats);
    cb()
  }

  this.timer = new Timer().start();
  this.emit('start');

  series([
      this.runBefore.bind(this)
    , this.runBenches.bind(this)
    , this.runSuites.bind(this)
    , this.runAfter.bind(this)
  ], iterator, done);
};

/**
 * .runBenches (callback)
 *
 * Will invoke the `.run` method of each
 * bench in this suite serially, taking into
 * account the delay option of the suite.
 *
 * @param {Function} callback
 * @name runBenches
 * @api public
 */

Runner.prototype.runBenches = function (cb) {
  var 