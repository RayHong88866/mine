// A facade from the tap-parser to the Mocha "Runner" object.
// Note that pass/fail/suite events need to also mock the "Runnable"
// objects (either "Suite" or "Test") since these have functions
// which are called by the formatters.

module.exports = Runner

// relevant events:
//
// start()
//   Start of the top-level test set
//
// end()
//   End of the top-level test set.
//
// fail(test, err)
//   any "not ok" test that is not the trailing test for a suite
//   of >0 test points.
//
// pass(test)
//   any "ok" test point that is not the trailing test for a suite
//   of >0 tests
//
// pending(test)
//   Any "todo" test
//
// suite(suite)
//   A suite is a child test with >0 test points.  This is a little bit
//   tricky, because TAP will provide a "child" event before we know
//   that it's a "suite".  We see the "# Subtest: name" comment as the
//   first thing in the subtest.  Then, when we get our first test point,
//   we know that it's a suite, and can emit the event with the mock suite.
//
// suite end(suite)
//   Emitted when we end the subtest
//
// test(test)
//   Any test point which is not the trailing test for a suite.
//
// test end(test)
//   Emitted immediately after the "test" event because test points are
//   not async in TAP.

var util = require('util')
var Test = require('./test.js')
var Suite = require('./suite.js')
var Writable = require('stream').Writable
if (!Writable) {
  try {
    Writable = require('readable-stream').Writable
  } catch (er) {
    throw new Error('Please install "readable-stream" to use this module ' +
                    'with Node.js v0.8 and before')
  }
}

var Parser = require('tap-parser')

// $1 = number, $2 = units
var timere = /^#\s*time=((?:0|[1-9][0-9]*?)(?:\.[0-9]+)?)(ms|s)?$/

util.inherits(Runner, Writable)

function Runner (options) {
  if (!(this instanceof Runner))
    return new Runner(options)

  var parser = this.parser = new Parser(options)
  this.startTime = new Date()

  attachEvents(this, parser, 0)
  Writable.call(this, options)
}

Runner.prototype.write = function () {
  if (!this.emittedStart) {
    this.emittedStart = true
    this.emit('start')
  }

  return this.parser.write.apply(this.parser, arguments)
}

Runner.prototype.end = function () {
  return this.parser.end.apply(this.parser, arguments)
}

Parser.prototype.fullTitle = function () {
  if (!this.parent)
    return this.name || ''
  else
    return (this.parent.fullTitle() + ' ' + (this.name || '')).trim()
}

function attachEvents (runner, parser, level) {
  parser.runner = runner

  if (level === 0) {
    parser.on('line', function (c) {
      runner.emit('line', c)
    })
    parser.on('version', function (v) {
      runner.emit('version', v)
    })
    parser.on('complete', function (res) {
      runner.emit('end')
    })
    parser.on('comment', function (c) {
      var tmatch = c.trim().match(timere)
      if (tmatch) {
        var t = +tmatch[1]
        if (tmatch[2] === 's')
          t *= 1000
        parser.time = t
        if (runner.stats)
          runner.stats.duration = t
      }
    })
  }

  parser.emittedSuite = false
  parser.didAssert = false
  parser.printed = false
  parser.name = ''
  parser.doingChild = null

  parser.on('complete', function (res) {
    if (!res.ok) {
      var fail = { ok: false, diag: {} }
      var count = res.count
      if (res.plan) {
        var plan = res.plan.end - res.plan.start + 1
        if (count !== plan) {
          fail.name = 'test count !== plan'
          fail.diag = {
            found: count,
            wanted: plan
      