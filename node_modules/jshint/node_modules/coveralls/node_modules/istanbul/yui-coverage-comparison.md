Comparison with YUI coverage
============================

Differences in features
-----------------------

* YUI coverage - line and function coverage. Istanbul - statement, function and branch coverage.
Reverse-engineers line-coverage from statement coverage with 100% fidelity at reporting time.

* Output report formats are not as extensive as YUI coverage reporting. It supports LCOV and a custom
HTML format (all-JS implementation) that only highlights missing coverage. "Standard" LCOV HTML reports can be
gotten by running `genhtml` on the `lcov.info` file. Notice that this will also have branch coverage
information, assuming you are using a recent `lcov` version.

Differences in processing
-------------------------

YUI coverage emits a function call to increment line/ function coverage as
appropriate. The function call also tests to see if that specific line/ function
was covered before and, if not, increments the coverage count for lines/ functions
as appropriate.

Istanbul emits code that does simple post-increments of object attributes without resorting
to function calls at all. This also means that it does not keep track of derived information
and does not bother to keep track of "how many statements/ branches/ functions have been
covered so far", preferring to do this at report generation time.

Differences in coverage object and generated code
-------------------------------------------------

These are the ways in which the objects differ:

* The YUI coverage object tracks line and function execution counts and also keeps track
of how many lines/ functions were covered. The Istanbul coverage object only keeps
tracks of statement, function and branch execution counts.

* Due to the backwards-incompatible format of the Istanbul coverage object, it is not
named `_yuitest_coverage` but `__coverage__` by default. You can change this to any name you
want using an instrumenter option.

* The YUI coverage object packs the entire source code of the file into an array for every
file. The Istanbul coverage object