/*!
 * should - test framework agnostic BDD-style assertions
 * @version v9.0.0
 * @author TJ Holowaychuk <tj@vision-media.ca>, Denis Bardadym <bardadymchik@gmail.com> and other contributors
 * @link https://github.com/shouldjs/should.js
 * @license MIT
 */

(function () {
  'use strict';

  var types = {
    NUMBER: 'number',
    UNDEFINED: 'undefined',
    STRING: 'string',
    BOOLEAN: 'boolean',
    OBJECT: 'object',
    FUNCTION: 'function',
    NULL: 'null',
    ARRAY: 'array',
    REGEXP: 'regexp',
    DATE: 'date',
    ERROR: 'error',
    ARGUMENTS: 'arguments',
    SYMBOL: 'symbol',
    ARRAY_BUFFER: 'array-buffer',
    TYPED_ARRAY: 'typed-array',
    DATA_VIEW: 'data-view',
    MAP: 'map',
    SET: 'set',
    WEAK_SET: 'weak-set',
    WEAK_MAP: 'weak-map',
    PROMISE: 'promise',

  // node buffer
    BUFFER: 'buffer',

  // dom html element
    HTML_ELEMENT: 'html-element',
    HTML_ELEMENT_TEXT: 'html-element-text',
    DOCUMENT: 'document',
    WINDOW: 'window',
    FILE: 'file',
    FILE_LIST: 'file-list',
    BLOB: 'blob',

    HOST: 'host',

    XHR: 'xhr',

    // simd
    SIMD: 'simd'
  };

  var toString = Object.prototype.toString;

  /**
   * Simple data function to store type information
   * @param {string} type Usually what is returned from typeof
   * @param {string} cls  Sanitized @Class via Object.prototype.toString
   * @param {string} sub  If type and cls the same, and need to specify somehow
   * @private
   * @example
   *
   * //for null
   * new Type('null');
   *
   * //for Date
   * new Type('object', 'date');
   *
   * //for Uint8Array
   *
   * new Type('object', 'typed-array', 'uint8');
   */
  function Type(type, cls, sub) {
    this.type = type;
    this.cls = cls;
    this.sub = sub;
  }

  /**
   * Function to store type checks
   * @private
   */
  function TypeChecker() {
    this.checks = [];
  }

  TypeChecker.prototype = {
    add: function(func) {
      this.checks.push(func);
      return this;
    },

    addTypeOf: function(type, res) {
      return this.add(function(obj, tpeOf) {
        if(tpeOf === type) {
          return new Type(res);
        }
      });
    },

    addClass: function(cls, res, sub) {
      return this.add(function(obj, tpeOf, objCls) {
        if(objCls === cls) {
          return new Type(types.OBJECT, res, sub);
        }
      });
    },

    getType: function(obj) {
      var typeOf = typeof obj;
      var cls = toString.call(obj);

      for(var i = 0, l = this.checks.length; i < l; i++) {
        var res = this.checks[i].call(this, obj, typeOf, cls);
        if(typeof res !== 'undefined') return res;
      }

    }
  };

  var main = new TypeChecker();

  //TODO add iterators

  main
    .addTypeOf(types.NUMBER, types.NUMBER)
    .addTypeOf(types.UNDEFINED, types.UNDEFINED)
    .addTypeOf(types.STRING, types.STRING)
    .addTypeOf(types.BOOLEAN, types.BOOLEAN)
    .addTypeOf(types.FUNCTION, types.FUNCTION)
    .addTypeOf(types.SYMBOL, types.SYMBOL)
    .add(function(obj, tpeOf) {
      if(obj === null) return new Type(types.NULL);
    })
    .addClass('[object String]', types.STRING)
    .addClass('[object Boolean]', types.BOOLEAN)
    .addClass('[object Number]', types.NUMBER)
    .addClass('[object Array]', types.ARRAY)
    .addClass('[object RegExp]', types.REGEXP)
    .addClass('[object Error]', types.ERROR)
    .addClass('[object Date]', types.DATE)
    .addClass('[object Arguments]', types.ARGUMENTS)

    .addClass('[object ArrayBuffer]', types.ARRAY_BUFFER)
    .addClass('[object Int8Array]', types.TYPED_ARRAY, 'int8')
    .addClass('[object Uint8Array]', types.TYPED_ARRAY, 'uint8')
    .addClass('[object Uint8ClampedArray]', types.TYPED_ARRAY, 'uint8clamped')
    .addClass('[object Int16Array]', types.TYPED_ARRAY, 'int16')
    .addClass('[object Uint16Array]', types.TYPED_ARRAY, 'uint16')
    .addClass('[object Int32Array]', types.TYPED_ARRAY, 'int32')
    .addClass('[object Uint32Array]', types.TYPED_ARRAY, 'uint32')
    .addClass('[object Float32Array]', types.TYPED_ARRAY, 'float32')
    .addClass('[object Float64Array]', types.TYPED_ARRAY, 'float64')

    .addClass('[object Bool16x8]', types.SIMD, 'bool16x8')
    .addClass('[object Bool32x4]', types.SIMD, 'bool32x4')
    .addClass('[object Bool8x16]', types.SIMD, 'bool8x16')
    .addClass('[object Float32x4]', types.SIMD, 'float32x4')
    .addClass('[object Int16x8]', types.SIMD, 'int16x8')
    .addClass('[object Int32x4]', types.SIMD, 'int32x4')
    .addClass('[object Int8x16]', types.SIMD, 'int8x16')
    .addClass('[object Uint16x8]', types.SIMD, 'uint16x8')
    .addClass('[object Uint32x4]', types.SIMD, 'uint32x4')
    .addClass('[object Uint8x16]', types.SIMD, 'uint8x16')

    .addClass('[object DataView]', types.DATA_VIEW)
    .addClass('[object Map]', types.MAP)
    .addClass('[object WeakMap]', types.WEAK_MAP)
    .addClass('[object Set]', types.SET)
    .addClass('[object WeakSet]', types.WEAK_SET)
    .addClass('[object Promise]', types.PROMISE)
    .addClass('[object Blob]', types.BLOB)
    .addClass('[object File]', types.FILE)
    .addClass('[object FileList]', types.FILE_LIST)
    .addClass('[object XMLHttpRequest]', types.XHR)
    .add(function(obj) {
      if((typeof Promise === types.FUNCTION && obj instanceof Promise) ||
          (typeof obj.then === types.FUNCTION)) {
            return new Type(types.OBJECT, types.PROMISE);
          }
    })
    .add(function(obj) {
      if(typeof Buffer !== 'undefined' && obj instanceof Buffer) {
        return new Type(types.OBJECT, types.BUFFER);
      }
    })
    .add(function(obj) {
      if(typeof Node !== 'undefined' && obj instanceof Node) {
        return new Type(types.OBJECT, types.HTML_ELEMENT, obj.nodeName);
      }
    })
    .add(function(obj) {
      // probably at the begginging should be enough these checks
      if(obj.Boolean === Boolean && obj.Number === Number && obj.String === String && obj.Date === Date) {
        return new Type(types.OBJECT, types.HOST);
      }
    })
    .add(function() {
      return new Type(types.OBJECT);
    });

  /**
   * Get type information of anything
   *
   * @param  {any} obj Anything that could require type information
   * @return {Type}    type info
   * @private
   */
  function getGlobalType(obj) {
    return main.getType(obj);
  }

  getGlobalType.checker = main;
  getGlobalType.TypeChecker = TypeChecker;
  getGlobalType.Type = Type;

  Object.keys(types).forEach(function(typeName) {
    getGlobalType[typeName] = types[typeName];
  });

  var EOL = '\n';

  function indent$1(v, indentation) {
    return v
      .split(EOL)
      .map(function(vv) {
        return indentation + vv;
      })
      .join(EOL);
  }

  function pad(str, value, filler) {
    str = String(str)
    var isRight = false;

    if(value < 0) {
      isRight = true;
      value = -value;
    }

    if(str.length < value) {
      var padding = new Array(value - str.length + 1).join(filler);
      return isRight ? str + padding : padding + str;
    } else{
      return str;
    }
  }

  function pad0(str, value) {
    return pad(str, value, '0');
  }

  function genKeysFunc(f) {
    return function(value) {
      var k = f(value);
      k.sort();
      return k;
    };
  }

  var INDENT = '  ';

  function addSpaces(str) {
    return indent$1(str, INDENT);
  }


  function Formatter(opts) {
    opts = opts || {};

    this.seen = [];
    var keysFunc;
    if(typeof opts.keysFunc === 'function') {
      keysFunc = opts.keysFunc;
    } else if(opts.keys === false) {
      keysFunc = Object.getOwnPropertyNames;
    } else {
      keysFunc = Object.keys;
    }

    this.keys = genKeysFunc(keysFunc);

    this.maxLineLength = typeof opts.maxLineLength === 'number' ? opts.maxLineLength : 60;
    this.propSep = opts.propSep || ',';

    this.isUTCdate = !!opts.isUTCdate;
  }

  Formatter.prototype = {
    constructor: Formatter,

    format: function(value) {
      var t = getGlobalType(value);
      var name1 = t.type, name2 = t.type;
      if(t.cls) {
        name1 += '_' + t.cls;
        name2 += '_' + t.cls;
      }
      if(t.sub) {
        name2 += '_' + t.sub;
      }
      var f = this['_format_' + name2] || this['_format_' + name1] || this['_format_' + t.type] || this.defaultFormat;
      return f.call(this, value).trim();
    },

    _formatObject: function(value, opts) {
      opts = opts || {};
      var mainKeys = opts.keys || this.keys(value);

      var len = 0;

      var formatPropertyValue = opts.formatPropertyValue || this.formatPropertyValue;
      var formatPropertyName = opts.formatPropertyName || this.formatPropertyName;
      var keyValueSep = opts.keyValueSep || ': ';
      var keyFilter = opts.keyFilter || function() { return true; };

      this.seen.push(value);
      var keys = [];

      mainKeys.forEach(function(key) {
        if(!keyFilter(key)) return;

        var fName = formatPropertyName.call(this, key);

        var f = (fName ? fName + keyValueSep : '') + formatPropertyValue.call(this, value, key);
        len += f.length;
        keys.push(f);
      }, this);
      this.seen.pop();

      (opts.additionalProperties || []).forEach(function(keyValue) {
        var f = keyValue[0] + keyValueSep + this.format(keyValue[1]);
        len += f.length;
        keys.push(f);
      }, this);

      var prefix = opts.prefix || Formatter.constructorName(value) || '';
      if(prefix.length > 0) prefix += ' ';

      var lbracket, rbracket;
      if(Array.isArray(opts.brackets)) {
        lbracket = opts.brackets && opts.brackets[0];
        rbracket = opts.brackets && opts.brackets[1];
      } else {
        lbracket = '{';
        rbracket = '}';
      }

      var rootValue = opts.value || '';

      if(keys.length === 0)
        return rootValue || (prefix + lbracket + rbracket);

      if(len <= this.maxLineLength) {
        return prefix + lbracket + ' ' + (rootValue ? rootValue + ' ' : '') + keys.join(this.propSep + ' ') + ' ' + rbracket;
      } else {
        return prefix + lbracket + '\n' + (rootValue ? '  ' + rootValue + '\n' : '') + keys.map(addSpaces).join(this.propSep + '\n') + '\n' + rbracket;
      }
    },

    formatPropertyName: function(name) {
      return name.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*$/) ? name : this.format(name);
    },

    formatProperty: function(value, prop) {
      var desc = Formatter.getPropertyDescriptor(value, prop);

      var propName = this.formatPropertyName(prop);

      var propValue = desc.get && desc.set ?
        '[Getter/Setter]' : desc.get ?
        '[Getter]' : desc.set ?
        '[Setter]' : this.seen.indexOf(desc.value) >= 0 ?
        '[Circular]' :
        this.format(desc.value);

      return propName + ': ' + propValue;
    },

    formatPropertyValue: function(value, prop) {
      var desc = Formatter.getPropertyDescriptor(value, prop);

      var propValue = desc.get && desc.set ?
        '[Getter/Setter]' : desc.get ?
        '[Getter]' : desc.set ?
        '[Setter]' : this.seen.indexOf(desc.value) >= 0 ?
        '[Circular]' :
        this.format(desc.value);

      return propValue;
    }
  };

  Formatter.add = function add(type, cls, sub, f) {
    var args = Array.prototype.slice.call(arguments);
    f = args.pop();
    Formatter.prototype['_format_' + args.join('_')] = f;
  };


  var functionNameRE = /^\s*function\s*(\S*)\s*\(/;

  Formatter.functionName = function functionName(f) {
    if(f.name) {
      return f.name;
    }
    var matches = f.toString().match(functionNameRE);
    if (matches === null) {
      // `functionNameRE` doesn't match arrow functions.
      return '';
    }
    var name = matches[1];
    return name;
  };

  Formatter.constructorName = function(obj) {
    while (obj) {
      var descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');
      if (descriptor !== undefined &&
          typeof descriptor.value === 'function') {

          var name = Formatter.functionName(descriptor.value);
          if(name !== '') {
            return name;
          }
      }

      obj = Object.getPrototypeOf(obj);
    }
  };

  Formatter.getPropertyDescriptor = function(obj, value) {
    var desc;
    try {
      desc = Object.getOwnPropertyDescriptor(obj, value) || {value: obj[value]};
    } catch(e) {
      desc = {value: e};
    }
    return desc;
  };

  Formatter.generateFunctionForIndexedArray = function generateFunctionForIndexedArray(lengthProp, name, padding) {
    return function(value) {
      var max = this.byteArrayMaxLength || 50;
      var length = value[lengthProp];
      var formattedValues = [];
      var len = 0;
      for(var i = 0; i < max && i < length; i++) {
        var b = value[i] || 0;
        var v = pad0(b.toString(16), padding);
        len += v.length;
        formattedValues.push(v);
      }
      var prefix = value.constructor.name || name || '';
      if(prefix) prefix += ' ';

      if(formattedValues.length === 0)
        return prefix + '[]';

      if(len <= this.maxLineLength) {
        return prefix + '[ ' + formattedValues.join(this.propSep + ' ') + ' ' + ']';
      } else {
        return prefix + '[\n' + formattedValues.map(addSpaces).join(this.propSep + '\n') + '\n' + ']';
      }
    };
  };

  Formatter.add('undefined', function() { return 'undefined' });
  Formatter.add('null', function() { return 'null' });
  Formatter.add('boolean', function(value) { return value ? 'true': 'false' });
  Formatter.add('symbol', function(value) { return value.toString() });

  ['number', 'boolean'].forEach(function(name) {
    Formatter.add('object', name, function(value) {
      return this._formatObject(value, {
        additionalProperties: [['[[PrimitiveValue]]', value.valueOf()]]
      });
    });
  });

  Formatter.add('object', 'string', function(value) {
    var realValue = value.valueOf();

    return this._formatObject(value, {
      keyFilter: function(key) {
        //skip useless indexed properties
        return !(key.match(/\d+/) && parseInt(key, 10) < realValue.length);
      },
      additionalProperties: [['[[PrimitiveValue]]', realValue]]
    });
  });

  Formatter.add('object', 'regexp', function(value) {
    return this._formatObject(value, {
      value: String(value)
    });
  });

  Formatter.add('number', function(value) {
    if(value === 0 && 1 / value < 0) return '-0';
    return String(value);
  });

  Formatter.add('string', function(value) {
    return '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
        .replace(/'/g, "\\'")
        .replace(/\\"/g, '"') + '\'';
  });

  Formatter.add('object', function(value) {
    return this._formatObject(value);
  });

  Formatter.add('object', 'arguments', function(value) {
    return this._formatObject(value, {
      prefix: 'Arguments',
      formatPropertyName: function(key) {
        if(!key.match(/\d+/)) {
          return this.formatPropertyName(key);
        }
      },
      brackets: ['[', ']']
    });
  });

  Formatter.add('object', 'array', function(value) {
    return this._formatObject(value, {
      formatPropertyName: function(key) {
        if(!key.match(/\d+/)) {
          return this.formatPropertyName(key);
        }
      },
      brackets: ['[', ']']
    });
  });


  function formatDate(value, isUTC) {
    var prefix = isUTC ? 'UTC' : '';

    var date = value['get' + prefix + 'FullYear']() +
      '-' +
      pad0(value['get' + prefix + 'Month']() + 1, 2) +
      '-' +
      pad0(value['get' + prefix + 'Date'](), 2);

    var time = pad0(value['get' + prefix + 'Hours'](), 2) +
      ':' +
      pad0(value['get' + prefix + 'Minutes'](), 2) +
      ':' +
      pad0(value['get' + prefix + 'Seconds'](), 2) +
      '.' +
      pad0(value['get' + prefix + 'Milliseconds'](), 3);

    var to = value.getTimezoneOffset();
    var absTo = Math.abs(to);
    var hours = Math.floor(absTo / 60);
    var minutes = absTo - hours * 60;
    var tzFormat = (to < 0 ? '+' : '-') + pad0(hours, 2) + pad0(minutes, 2);

    return date + ' ' + time + (isUTC ? '' : ' ' + tzFormat);
  }

  Formatter.add('object', 'date', function(value) {
    return this._formatObject(value, { value: formatDate(value, this.isUTCdate) });
  });

  Formatter.add('function', function(value) {
    return this._formatObject(value, {
      additionalProperties: [['name', Formatter.functionName(value)]]
    });
  });

  Formatter.add('object', 'error', function(value) {
    return this._formatObject(value, {
      prefix: value.name,
      additionalProperties: [['message', value.message]]
    });
  });

  Formatter.add('object', 'buffer', Formatter.generateFunctionForIndexedArray('length', 'Buffer', 2));

  Formatter.add('object', 'array-buffer', Formatter.generateFunctionForIndexedArray('byteLength', 'ArrayBuffer', 2));

  Formatter.add('object', 'typed-array', 'int8', Formatter.generateFunctionForIndexedArray('length', 'Int8Array', 2));
  Formatter.add('object', 'typed-array', 'uint8', Formatter.generateFunctionForIndexedArray('length', 'Uint8Array', 2));
  Formatter.add('object', 'typed-array', 'uint8clamped', Formatter.generateFunctionForIndexedArray('length', 'Uint8ClampedArray', 2));

  Formatter.add('object', 'typed-array', 'int16', Formatter.generateFunctionForIndexedArray('length', 'Int16Array', 4));
  Formatter.add('object', 'typed-array', 'uint16', Formatter.generateFunctionForIndexedArray('length', 'Uint16Array', 4));

  Formatter.add('object', 'typed-array', 'int32', Formatter.generateFunctionForIndexedArray('length', 'Int32Array', 8));
  Formatter.add('object', 'typed-array', 'uint32', Formatter.generateFunctionForIndexedArray('length', 'Uint32Array', 8));

  //TODO add float32 and float64

  Formatter.add('object', 'promise', function() {
    return '[Promise]';//TODO it could be nice to inspect its state and value
  });

  Formatter.add('object', 'xhr', function() {
    return '[XMLHttpRequest]';//TODO it could be nice to inspect its state
  });

  Formatter.add('object', 'html-element', function(value) {
    return value.outerHTML;
  });

  Formatter.add('object', 'html-element', '#text', function(value) {
    return value.nodeValue;
  });

  Formatter.add('object', 'html-element', '#document', function(value) {
    return value.documentElement.outerHTML;
  });

  Formatter.add('object', 'host', function() {
    return '[Host]';
  });

  Formatter.add('object', 'set', function(value) {
    var iter = value.values();
    var len = 0;

    this.seen.push(value);

    var props = [];

    var next = iter.next();
    while(!next.done) {
      var val = next.value;
      var f = this.format(val);
      len += f.length;
      props.push(f);

      next = iter.next();
    }

    this.seen.pop();

    if(props.length === 0) return 'Set {}';

    if(len <= this.maxLineLength) {
      return 'Set { ' + props.join(this.propSep + ' ') + ' }';
    } else {
      return 'Set {\n' + props.map(addSpaces).join(this.propSep + '\n') + '\n' + '}';
    }
  });

  Formatter.add('object', 'map', function(value) {
    var iter = value.entries();
    var len = 0;

    this.seen.push(value);

    var props = [];

    var next = iter.next();
    while(!next.done) {
      var val = next.value;
      var fK = this.format(val[0]);
      var fV = this.format(val[1]);

      var f;
      if((fK.length + fV.length + 4) <= this.maxLineLength) {
        f = fK + ' => ' + fV;
      } else {
        f = fK + ' =>\n' + fV;
      }

      len += fK.length + fV.length + 4;
      props.push(f);

      next = iter.next();
    }

    this.seen.pop();

    if(props.length === 0) return 'Map {}';

    if(len <= this.maxLineLength) {
      return 'Map { ' + props.join(this.propSep + ' ') + ' }';
    } else {
      return 'Map {\n' + props.map(addSpaces).join(this.propSep + '\n') + '\n' + '}';
    }
  });

  function simdVectorFormat(constructorName, length) {
    return function(value) {
      var Constructor = value.constructor;
      var extractLane = Constructor.extractLane;

      var len = 0;
      var props = [];

      for(var i = 0; i < length; i ++) {
        var key = this.format(extractLane(value, i));
        len += key.length;
        props.push(key);
      }

      if(len <= this.maxLineLength) {
        return constructorName + ' [ ' + props.join(this.propSep + ' ') + ' ]';
      } else {
        return constructorName + ' [\n' + props.map(addSpaces).join(this.propSep + '\n') + '\n' + ']';
      }
    }
  }

  Formatter.add('object', 'simd', 'bool16x8', simdVectorFormat('Bool16x8', 8));
  Formatter.add('object', 'simd', 'bool32x4', simdVectorFormat('Bool32x4', 4));
  Formatter.add('object', 'simd', 'bool8x16', simdVectorFormat('Bool8x16', 16));
  Formatter.add('object', 'simd', 'float32x4', simdVectorFormat('Float32x4', 4));
  Formatter.add('object', 'simd', 'int16x8', simdVectorFormat('Int16x8', 8));
  Formatter.add('object', 'simd', 'int32x4', simdVectorFormat('Int32x4', 4));
  Formatter.add('object', 'simd', 'int8x16', simdVectorFormat('Int8x16', 16));
  Formatter.add('object', 'simd',